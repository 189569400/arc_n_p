13.3 Relationships between Tactics and Patterns 策略与模式的关系
===

[TOC]

Patterns and tactics together constitute the software architect’s primary tools of the trade. How do they relate to each other?

## Patterns comprise tactics

As we said in the introduction to this chapter, tactics are the “building blocks” of design from which architectural patterns are created. Tactics are atoms and patterns are molecules. Most patterns consist of (are constructed from) several different tactics, and although these tactics might all serve a common purpose—such as promoting modifiability, for example—they are often chosen to promote different quality attributes. For example, a tactic might be chosen that makes an availability pattern more secure, or that mitigates the performance impact of a modifiability pattern.

Consider the example of the layered pattern, the most common pattern in all of software architecture (virtually all nontrivial systems employ layering). The layered pattern can be seen as the amalgam of several tactics—increase semantic coherence, abstract common services, encapsulate, restrict communication paths, and use an intermediary. For example:
* _Increase semantic coherence_. The goal of ensuring that a layer’s respon-sibilities all work together without excessive reliance on other layers is achieved by choosing responsibilities that have semantic coherence. Doing so binds responsibilities that are likely to be affected by a change. For example, responsibilities that deal with hardware should be allocated to a hardware layer and not to an application layer; a hardware respon-sibility typically does not have semantic coherence with the application responsibilities.
* _Restrict dependencies_. Layers define an ordering and only allow a layer to use the services of its adjacent lower layer. The possible communication paths are reduced to the number of layers minus one. This limitation has a great influence on the dependencies between the layers and makes it much easier to limit the side effects of replacing a layer.

Without any one of its tactics, the pattern might be ineffective. For example, if the restrict dependencies tactic is not employed, then any function in any layer can call any other function in any other layer, destroying the low coupling that makes the layering pattern effective. If the increase semantic coherence tactic is not employed, then functionality could be randomly sprinkled throughout the layers, destroying the separation of concerns, and hence ease of modification, which is the prime motivation for employing layers in the first place.

Table 13.12 shows a number of the architectural patterns described in the book Pattern-Oriented Software Architecture Volume 1: A System of Patterns, by Buschmann et al., and shows which modifiability tactics they employ.

## Using Tactics to Augment Patterns
A pattern is described as a solution to a class of problems in a general context. When a pattern is chosen and applied, the context of its application becomes very specific. A documented pattern is therefore underspecified with respect to apply-ing it in a specific situation.

To make a pattern work in a given architectural context, we need to examine it from two perspectives:
* The inherent quality attribute tradeoffs that the pattern makes. Patterns exist to achieve certain quality attributes, and we need to compare the ones they promote (and the ones they diminish) with our needs.
* Other quality attributes that the pattern isn’t directly concerned with, but which it nevertheless affects, and which are important in our application.

TABLE 13.12 Architecture Patterns and Corresponding Tactics ([Bachmann 07])




Modifiability | | | | | | | | | | | 
---|---|---|---|---|---|---|---|---|---|---
- | Increase Cohesion | - | Reduce Coupling | - | - | - | - | Defer Binding Time | - | -
Pattern | Increase Semantic Coherence | Abstract Common Services | Encapsulate | Use a Wrapper | Restrict Comm. Paths | Use an Intermediary | Raise the Abstraction Level | Use Runtime Registration | Use Startup-time Binding | Use Runtime Binding
Layered           | X | X | X |   | X | X | X |   |   | 
Pipes and Filters | X |   | X |   | X | X |   |   | X | 
Blackboard        | X | X |   |   | X | X | X | X |   | X
Broker            | X | X | X |   | X | X | X | X |   | 
Model View Controller            | X |   | X |   |   | X |  |  |  | X
Presentation Abstraction Control | X | | X | | | X | X | | | | 
Microkernel       | X | X | X |   | X | X |   |   |   | 
Reflection        | X | X |   |   |   |   |   |   |   | 

To illustrate these concerns in particular, and how to use tactics to augment patterns in general, we’ll use the broker pattern as a starting point.

The broker pattern is widely used in distributed systems and dates back at least to its critical role in CORBA-based systems. Broker is a crucial component of any large-scale, dynamic, service-oriented architecture.

Using this pattern, a client requesting some information from a server does not need to know the location or APIs of the server. The client simply contacts the broker (typically through a client-side proxy); this is illustrated in the UML sequence diagram in Figure 13.16.

### Weaknesses of the broker Pattern. 
In Section 13.2 we enumerated sev-eral weaknesses of the broker pattern. Here we will examine these weaknesses in more detail. The broker pattern has several weaknesses with respect to certain quality attributes. For example:
* _Availability_. The broker, if implemented as suggested in Figure 13.6, is a single point of failure. The liveness of servers, the broker, and perhaps even the clients need to be monitored, and repair mechanisms must be provided.

![](fig.13.16)
FIGURE 13.16 A sequence diagram showing a typical client-server interaction mediated by a broker

* _Performance_. The levels of indirection between the client (requesting the information or service) and the server (providing the information or service) add overhead, and hence add latency. Also, the broker is a potential performance bottleneck if direct communication between the client and server is not desired (for example, for security reasons).
* _Testability_. Brokers are employed in complex multi-process and multi-processor systems. Such systems are typically highly dynamic. Requests and responses are typically asynchronous. All of this makes testing and debugging such systems extremely difficult. But the description of the broker pattern provides no testing functionality, such as testing interfaces, state or activity capture and playback capabilities, and so forth.
* _Security_. Because the broker pattern is primarily used when the system spans process and processor boundaries—such as on web-based systems—security is a legitimate concern. However, the broker pattern as presented does not offer any means to authenticate or authorize clients or servers, and provides no means of protecting the communication between clients and
servers.

Of these quality attributes, the broker pattern is mainly associated with poor performance (the well-documented price for the loose coupling it brings to systems). It is largely unconcerned with the other quality attributes in this list; they aren’t mentioned in most published descriptions. But as the other bullets show, they can be unacceptable “collateral damage” that come with the broker’s benefits.

### Improving the Broker Pattern with Tactics. 
How can we use tactics to plug the gaps between the “out of the box” broker pattern and a version of it that will let us meet the requirements of a demanding distributed system? Here are some options:
* The increase available resources performance tactic would lead to multiple brokers, to help with performance and availability.
* The maintain multiple copies tactic would allow each of these brokers to share state, to ensure that they respond identically to client requests.
* Load balancing (an application of the scheduling resources tactic) would ensure that one broker is not overloaded while another one sits idle.
* Heartbeat, exception detection, or ping/echo would give the replicated brokers a way of notifying clients and notifying each other when one of them is out of service, as a means of detecting faults.

Of course, each of these tactics brings a tradeoff. Each complicates the de-sign, which will now take longer to implement, be more costly to acquire, and be more costly to maintain. Load balancing introduces indirection that will add latency to each transaction, thus giving back some of the performance it was in-tended to increase. And the load balancer is a single point of failure, so it too must be replicated, further increasing the design cost and complexity.