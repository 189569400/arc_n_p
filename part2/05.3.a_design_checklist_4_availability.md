5.3 A Design Checklist for Availability
===

Table 5.4 is a checklist to support the design and analysis process for availability.

表5.4是一个清单，以支持可用性的设计和分析过程。

**Table 5.4** Checklist to Support the Design and Analysis Process for Availability 支持可用性的设计和分析过程的清单

Category | Checklist
--|--
Allocation of Responsibilities | Determine the system responsibilities that need to be highly available. Within those responsibilities, ensure that additional responsibilities have been allocated to detect an omission, crash, incorrect timing, or incorrect response. Additionally, ensure that there are responsibilities to do the following: <br> <li> Log the fault <br> <li> Notify appropriate entities (people or systems) <br> <li> Disable the source of events causing the fault <br> <li> Be temporarily unavailable <br> <li> Fix or mask the fault/failure <br> <li> Operate in a degraded mode
Coordination Model | Determine the system responsibilities that need to be highly available. With respect to those responsibilities, do the following: <br> <li> Ensure that coordination mechanisms can detect an omission, crash, incorrect timing, or incorrect response. Consider, for example, whether guaranteed delivery is necessary. Will the coordination work under conditions of degraded communication? <br> <li> Ensure that coordination mechanisms enable the logging of the fault, notification of appropriate entities, disabling of the source of the events causing the fault, fixing or masking the fault, or operating in a degraded mode. <br> <li> Ensure that the coordination model supports the replacement of the artifacts used (processors, communications channels, persistent storage, and processes). For example, does replacement of a server allow the system to continue to operate? <br> <li> Determine if the coordination will work under conditions of degraded communication, at startup/shutdown, in repair mode, or under overloaded operation. For example, how much lost information can the coordination model withstand and with what consequences?
Data Model | Determine which portions of the system need to be highly available. Within those portions, determine which data abstractions, along with their operations or their properties, could cause a fault of omission, a crash, incorrect timing behavior, or an incorrect response. <br> For those data abstractions, operations, and properties, ensure that they can be disabled, be temporarily unavailable, or be fixed or masked in the event of a fault. <br> For example, ensure that write requests are cached if a server is temporarily unavailable and performed when the server is returned to service.
Mapping among Architectural Elements | Determine which artifacts (processors, communication channels, persistent storage, or processes) may produce a fault: omission, crash, incorrect timing, or incorrect response. <br> Ensure that the mapping (or remapping) of architectural elements is flexible enough to permit the recovery from the fault. This may involve a consideration of the following:  <br> <li> Which processes on failed processors need to be reassigned at runtime <br> <li> Which processors, data stores, or communication channels can be activated or reassigned at runtime <br> <li> How data on failed processors or storage can be served by replacement units <br> <li> How quickly the system can be reinstalled based on the units of delivery provided <br> <li> How to (re)assign runtime elements to processors, communication channels, and data stores  <br> <li> When employing tactics that depend on redundancy of functionality, the mapping from modules to redundant components is important. For example, it is possible to write one module that contains code appropriate for both the active component and backup components in a protection group.
Resource Management | Determine what critical resources are necessary to continue operating in the presence of a fault: omission, crash, incorrect timing, or incorrect response. Ensure there are sufficient remaining resources in the event of a fault to log the fault; notify appropriate entities (people or systems); disable the source of events causing the fault; be temporarily unavailable; fix or mask the fault/failure; operate normally, in startup, shutdown, repair mode, degraded operation, and overloaded operation. <br> Determine the availability time for critical resources, what critical resources must be available during specified time intervals, time intervals during which the critical resources may be in a degraded mode, and repair time for critical resources. Ensure that the critical resources are available during these time intervals. <br> For example, ensure that input queues are large enough to buffer anticipated messages if a server fails so that the messages are not permanently lost.

Table 5.4 Checklist to Support the Design and Analysis Process for
Availability, continued

Category | Checklist
--|--
Binding Time | Determine how and when architectural elements are bound. If late binding is used to alternate between components that can themselves be sources of faults (e.g., processes, processors, communication channels), ensure the chosen availability strategy is sufficient to cover faults introduced by all sources. For example: <br> <li> If late binding is used to switch between artifacts such as processors that will receive or be the subject of faults, will the chosen fault detection and recovery mechanisms work for all possible bindings? <br> <li> If late binding is used to change the definition or tolerance of what constitutes a fault (e.g., how long a process can go without responding before a fault is assumed), is the recovery strategy chosen sufficient to handle all cases? For example, if a fault is flagged after 0.1 milliseconds, but the recovery mechanism takes 1.5 seconds to work, that might be an unacceptable mismatch. <br> <li> What are the availability characteristics of the late binding mechanism itself? Can it fail? 
Choice of Technology | Determine the available technologies that can (help) detect faults, recover from faults, or reintroduce failed components. <br> Determine what technologies are available that help the response to a fault (e.g., event loggers). <br> Determine the availability characteristics of chosen technologies themselves: What faults can they recover from? What faults might they introduce into the system?

类别 | Checklist
--|--
职责分配 | 确定需要高度可用的系统职责。 在这些职责中，请确保已分配其他职责以检测遗漏，崩溃，错误的时间或错误的响应。 此外，请确保有责任执行以下操作：<li>记录故障</li> <li>通知适当的实体（人员或系统）</li> <li>禁用导致故障的事件源</li> <li>暂时无法使用</li> <li> 修复或掩盖故障/失败</li> <li>在降级模式下操作</li>
协调模型 | 确定需要高度可用的系统职责。关于这些责任，请执行以下操作：<ul><li>确保协调机制可以检测到遗漏，崩溃，错误的时间安排或错误的响应。例如，考虑是否需要保证交付。协调将在通讯质量下降的情况下进行吗？</li> <li>确保协调机制启用故障记录，通知的适当实体，禁用导致故障的事件源，修复或掩盖故障或以降级模式运行。</li> <li>确保协调模型支持替换所使用的构件（处理器，通信通道，持久性存储和进程）。例如，更换服务器是否允许系统继续运行？</li> <li>确定协调在通信质量下降，启动/关闭，维修模式还是过载的情况下是否可以工作。例如，协调模型可以承受多少丢失的信息，其后果是什么？</li></ul>
数据模型 | 确定系统的哪些部分需要高度可用。 在这些部分中，确定哪些数据抽象及其操作或属性可能导致遗漏故障，崩溃，错误的计时行为或错误的响应。<br> 对于那些数据抽象，操作和属性，请确保它们可以被禁用，暂时不可用，或者在发生故障时被修复或屏蔽。<br>例如，如果服务器暂时不可用并在服务器恢复服务时执行，请确保写入请求被缓存。
架构元素之间的映射 | 确定哪些工件（处理器，通信通道，持久性存储或进程）可能产生故障：遗漏，崩溃，错误的计时或错误的响应。<br>确保架构元素的映射（或重新映射）足够灵活以允许从故障中恢复。 这可能涉及以下方面的考虑：<li>故障处理器上的哪些进程需要在运行时重新分配</li> <li>在运行时可以激活或重新分配哪些处理器，数据存储或通信通道</li> <li>更换单元如何处理故障处理器或存储上的数据</li> <li>根据提供的交付单位，可以多快的时间重新安装系统</li> <li>如何将运行时元素（重新）分配给处理器，进行通讯渠道和数据存储</li> <li>当采用依赖于功能冗余的策略时，从模块到冗余组件的映射很重要。 例如，可以编写一个模块，其中包含适用于保护组中活动组件和备用组件的代码。</li>
资源管理 | 确定在出现故障时继续运行所需的关键资源：遗漏，崩溃，错误的时间或错误的响应。 确保在发生故障时有足够的剩余资源来记录故障； 通知适当的实体（人员或系统）； 禁用导致故障的事件源； 暂时不可用； 修复或掩盖故障/失败； 在启动，关闭，修复模式，降级操作和过载操作中正常运行。<br>确定关键资源的可用性时间，在指定的时间间隔内必须有哪些关键资源，关键资源可能处于降级模式的时间间隔以及关键资源的修复时间。 确保在这些时间间隔内关键资源可用。<br>例如，确保输入队列足够大，以便在服务器发生故障时缓冲预期的消息，以使消息不会永久丢失。
绑定时间 | 确定如何以及何时绑定架构元素。 如果使用后期绑定在本身可能是故障源的组件（例如流程，处理器，通信通道）之间进行切换，请确保所选的可用性策略足以覆盖所有故障源所引入的故障。 例如：<li>如果使用后期绑定在工件（例如将要接收或成为故障对象的处理器）之间进行切换，那么所选的故障检测和恢复机制是否适用于所有可能的绑定？</li> <li>如果使用后期绑定来更改故障原因的定义或容忍度（例如，在假定故障之前流程可以进行多长时间而没有响应），那么选择的恢复策略是否足以处理所有情况？ 例如，如果在0.1毫秒后标记了一个故障，但是恢复机制需要1.5秒钟才能起作用，那么这可能是不可接受的不匹配。 </li> <li>后期绑定机制本身的可用性特征是什么？ 会失败吗？ </li> 
技术选择 | 确定可以（帮助）检测故障，从故障中恢复或重新引入故障组件的可用技术。<br> 确定哪些可用的技术可以帮助对故障做出响应（例如，事件记录器）。<br>确定所选技术本身的可用性特征：它们可以从哪些故障中恢复？ 他们可能将哪些故障引入系统？