11.2 Tactics for usability
===

Recall that usability is concerned with how easy it is for the user to accomplish a desired task, as well as the kind of support the system provides to the user. Researchers in human-computer interaction have used the terms user initiative, system initiative, and mixed initiative to describe which of the human-computer pair takes the initiative in performing certain actions and how the interaction pro-ceeds. Usability scenarios can combine initiatives from both perspectives. For example, when canceling a command, the user issues a cancel—user initiative—and the system responds. During the cancel, however, the system may put up a progress indicator—system initiative. Thus, cancel may demonstrate mixed ini-tiative. We use this distinction between user and system initiative to discuss the tactics that the architect uses to achieve the various scenarios.

Figure 11.2 shows the goal of the set of runtime usability tactics.

![](fig.11.1)
FIGURE 11.1 Sample concrete usability scenario

![](fig.11.2)
FIGURE 11.2 The goal of runtime usability tactics


> Separate the User Interface!
> 
> One of the most helpful things an architect can do to make a system usable is to facilitate experimentation with the user interface via the con-struction of rapid prototypes. Building a prototype, or several prototypes, to let real users experience the interface and give their feedback pays enormous dividends. The best way to do this is to design the software so that the user interface can be quickly changed.
>
> Tactics for modifiability that we saw in Chapter 7 support this goal per-fectly well, especially these:
> * Increase semantic coherence, encapsulate, and co-locate related re-sponsibilities, which localize user interface responsibilities to a single place
> * Restrict dependencies, which minimizes the ripple effect to other soft-ware when the user interface changes
> * Defer binding, which lets you make critical user interface choices without having to recode
>
> Defer binding is especially helpful here, because you can expect that your product’s user interface will face pressure to change during testing and even after it goes to market.
>
> User interface generation tools are consistent with these tactics; most produce a single module with an abstract interface to the rest of the soft-ware. Many provide the capability to change the user interface after compile time. You can do your part by restricting dependencies on the generated module, should you later decide to adopt a different tool.
>
> Much work in different user interface separation patterns occurred in the 1980s and 90s. With the advent of the web and the modernization of the model-view-controller (MVC) pattern to reflect web interfaces, MVC has become the dominant separation pattern. Now the MVC pattern is built into a wide variety of different frameworks. (See Chapter 14 for a discussion of MVC.) MVC makes it easy to provide multiple views of the data, supporting user initiative, as we discuss next.
>
> Many times quality attributes are in conflict with each other. Usability and modifiability, on the other hand, often complement each other, because one of the best ways to make a system more usable is to make it modifiable. However, this is not always the case. In many systems busi-ness rules drive the UI—for example, specifying how to validate input. To realize this validation, the UI may need to call a server (which can neg-atively affect performance). To get around this performance penalty, the architect may choose to duplicate these rules in the client and the server, which then makes evolution difficult. Alas, the architect’s life is never easy!

There is a connection between the achievement of usability and modifiabil-ity. The user interface design process consists of generating and then testing a user interface design. Deficiencies in the design are corrected and the process repeats. If the user interface has already been constructed as a portion of the sys-tem, then the system must be modified to reflect the latest design. Hence the con-nection with modifiability. This connection has resulted in standard patterns to support user interface design (see sidebar).

## Support user Initiative

Once a system is executing, usability is enhanced by giving the user feed-back as to what the system is doing and by allowing the user to make appro-priate responses. For example, the tactics described next—cancel, undo, pause/resume, and aggregate—support the user in either correcting errors or being more efficient.

The architect designs a response for user initiative by enumerating and al-locating the responsibilities of the system to respond to the user command. Here are some common examples of user initiative:
* _Cancel_. When the user issues a cancel command, the system must be listening for it (thus, there is the responsibility to have a constant listener that is not blocked by the actions of whatever is being canceled); the command being canceled must be terminated; any resources being used by the canceled command must be freed; and components that are collaborating with the canceled command must be informed so that they can also take appropriate action.
* _Undo_. To support the ability to undo, the system must maintain a sufficient amount of information about system state so that an earlier state may be restored, at the user’s request. Such a record may be in the form of state “snapshots”—for example, checkpoints—or as a set of reversible oper-ations. Not all operations can be easily reversed: for example, changing all occurrences of the letter “a” to the letter “b” in a document cannot be reversed by changing all instances of “b” to “a”, because some of those in-stances of “b” may have existed prior to the original change. In such a case the system must maintain a more elaborate record of the change. Of course, some operations, such as ringing a bell, cannot be undone.
* _Pause/resume_. When a user has initiated a long-running operation—say, downloading a large file or set of files from a server—it is often useful to provide the ability to pause and resume the operation. Effectively pausing a long-running operation requires the ability to temporarily free resources so that they may be reallocated to other tasks.
* _Aggregate_. When a user is performing repetitive operations, or operations that affect a large number of objects in the same way, it is useful to provide the ability to aggregate the lower-level objects into a single group, so that the operation may be applied to the group, thus freeing the user from the drudgery (and potential for mistakes) of doing the same operation repeated-ly. For example, aggregate all of the objects in a slide and change the text to 14-point font.

## Support System Initiative

When the system takes the initiative, it must rely on a model of the user, the task being undertaken by the user, or the system state itself. Each model requires various types of input to accomplish its initiative. The support system initiative tactics are those that identify the models the system uses to predict either its own behavior or the user’s intention. Encapsulating this information will make it easier for it to be tailored or modified. Tailoring and modification can be either dynamically based on past user behavior or offline during development. These tactics are the following:
* _Maintain task model_. The task model is used to determine context so the system can have some idea of what the user is attempting and provide assistance. For example, knowing that sentences start with capital letters would allow an application to correct a lowercase letter in that position.
* _Maintain user model_. This model explicitly represents the user’s knowledge of the system, the user’s behavior in terms of expected response time, and other aspects specific to a user or a class of users. For example, maintaining a user model allows the system to pace mouse selection so that not all of the document is selected when scrolling is required. Or a model can control the amount of assistance and suggestions automatically provided to a user. A special case of this tactic is commonly found in user interface customiza-tion, wherein a user can explicitly modify the system’s user model.
* _Maintain system model_. Here the system maintains an explicit model of itself. This is used to determine expected system behavior so that appropriate feedback can be given to the user. A common manifestation of a system model is a progress bar that predicts the time needed to complete the current activity.

  Figure 11.3 shows a summary of the tactics to achieve usability.

![](fig.11.3)
FIGURE 11.3 Usability tactics