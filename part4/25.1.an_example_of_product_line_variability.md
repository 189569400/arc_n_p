25.1 An Example of Product Line Variability 产品线可变性的一个例子
===

The following example will help us illustrate the concept of product line variability. In a product line of software to support U.S. bank loan offices, suppose we have a software module that calculates what a customer owes in the current month. For 18 of the 21 products in our product line, this module is completely adequate. However, our company is about to enter the market in the state of Delaware, which has certain laws that affect what a customer can owe. For the three products we plan to sell in Delaware, we need a module that differs from the “standard” module. Analysis shows that the difference will affect about 250 lines of source code in our 8,000-line module.

下面的例子将帮助我们说明产品线可变性的概念。在支持美国银行贷款办公室的软件产品线中，假设我们有一个软件模块，用于计算客户当月的欠款。对于我们产品线的21种产品中的18种来说，这个模块是完全足够的。然而，我们的公司即将进入特拉华州的市场，该州有一些法律影响客户的债务。对于我们计划在特拉华州销售的三种产品，我们需要一个不同于“标准”模块的模块。分析表明，这种差异将影响模块的8000行源代码中的大约250行。

To build one of the Delaware products, what do we do? An obvious option is to copy the module, change the 250 or so lines, and use the new version in the three products. This practice is called “clone-and-own” —— the new projects “clone” the module, change it, and then “own” the new version. Most companies, when faced with this situation, resort to clone-and-own. It’s expedient in that it provides a quick start to a new product, but it comes with a substantial cost down the road.

要生产特拉华州的产品，我们该怎么做？一个明显的选择是复制模块，更改大约250行，并在这三种产品中使用新版本。这种做法被称为“克隆自有产品”——新项目“克隆”模块，对其进行更改，然后“拥有”新版本。大多数公司在面临这种情况时，都会选择克隆自有产品。这是一种权宜之计，因为它为一种新产品提供了一个快速的开始，但同时也带来了巨大的成本。

The problem with clone-and-own is that it doesn’t scale. Suppose each of our 21 products comprises roughly 100 modules. If each module is allowed to diverge for each product, that’s potentially 2,100 modules that the maintenance staff has to deal with, each one spiraling off on its own separate maintenance trajectory based on the needs of the lone project each version is used in. Many companies’ growth in a market is limited—brought to a halt, in fact—by their inability to staff the maintenance of so many separate versions of so many different assets composing the products in their portfolio. An organization fielding several versions of several products finds itself dealing with a staggeringly complex code base. The strain begins to show when a systematic change needs to be made to all of the products—for example, to add a new feature, or migrate to a new platform, or make the user interface work in a different language. Because each version of each component used in each product has been allowed to evolve separately, now suddenly making a systematic change becomes prohibitively expensive (and only gets worse each time a new product is added—the labor involved grows as the square of the number of products). It only takes a few such portfolio-wide changes before organizations feel that they’ve hit a wall of complexity and expense.

"克隆自有产品"的问题在于它无法扩展。假设我们的21个产品中的每一个都包含大约100个模块。如果允许每个模块针对每个产品进行分流，那么维护人员可能需要处理2100个模块，每个模块根据每个版本所使用的单独项目的需求，按照各自的维护轨迹螺旋式地运行。许多公司在一个市场上的增长受到限制而陷入停滞，事实上，这是因为它们无法为构成其投资组合中产品的这么多不同资产的这么多不同版本配备维护人员。一个部署了多个产品的多个版本的组织发现自己正在处理一个极其复杂的代码库。当需要对所有产品进行系统性更改时（例如，添加新功能、迁移到新平台或使用户界面使用不同的语言），压力就开始显现出来。由于每个产品中使用的每个组件的每个版本都被允许单独发展，现在突然进行系统性的更改变得昂贵得令人望而却步（而且每次添加新产品时，所涉及的劳动力都会随着产品数量的平方而增加）。在组织感觉到他们已经撞上了复杂性和费用的墙之前，只需要进行几次这样的投资组合范围的更改。

So much for clone-and-own. What else can we do? Instead of allowing up to 21 versions of each module, we would much rather find a way to take advantage of the fact that these nearly identical modules vary only in small, well-defined ways. To take advantage of their similarities, we introduce a variation mechanism into the module. (Variation mechanisms are often realized as tactics, such as the “defer binding” set of tactics described in Chapter 7.) This variation mechanism will let us maintain a single module that can adapt to the range of variations in the applications (in our example, the 21 banking products) that it has to support. If we plan to market our products in states that, like Delaware, have their own laws affecting what a customer owes, we may need to support additional variations of the module. So our variation mechanism should be able to accommodate those possibilities as well.

"克隆自有产品"就到此为止。我们还能做什么？与其允许每个模块最多有21个版本，我们更愿意找到一种方法来利用这样一个事实，即这些几乎相同的模块只以小的、定义良好的方式变化。为了利用它们的相似性，我们在模块中引入了一种差异化机制。（差异化机制通常被视为策略，如第7章中描述的“延迟绑定”策略集。）这种差异化机制将使我们能够维护一个单一的模块，该模块可以适应其必须支持的应用程序（在我们的示例中为21种银行产品）的变化范围。如果我们计划在特拉华等州销售我们的产品，这些州有自己的法律影响客户的债务，我们可能需要支持该模块的其他变体。所以我们的差异化机制也应该能够适应这些可能性。

The payoff for this up-front planning is that an asset used in any of the products exists as a single version that (through the exercising of built-in variation mechanisms) works for all of the products in the product line. And now, making a portfolio-wide change merely consists of changing the core assets that are affected. Because all future versions of all products use the same core assets, changing the core asset base has the effect of changing all of the products in the organization’s portfolio.

这种预先规划的回报是，任何产品中使用的资产都作为单一版本存在（通过使用内置的变化机制），适用于产品线中的所有产品。而现在，在整个投资组合范围内做出改变仅仅是改变受影响的核心资产。由于所有产品的所有未来版本都使用相同的核心资产，因此更改核心资产库会产生更改组织产品组合中所有产品的效果。
