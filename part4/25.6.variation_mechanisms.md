25.6 Variation Mechanisms 差异化机制
===

In a conventional architecture, the mechanism for achieving different instances often comes down to modifying the code. But in a software product line, modifying code is undesirable, because this leads to a large number of separately maintained implementations that quickly outstrip an organization’s ability to keep them up to date and consistent.

Three primary architectural variation mechanisms are these:
以下是三种主要的架构差异化机制：

* _Inclusion or omission of elements_. This decision can be reflected in the build procedures for different products, or the implementation of an element can be conditionally compiled based on some parameter indicating its presence or absence.
* _Inclusion of a different number of replicated elements_. For instance, high-capacity variants might be produced by adding more servers—the actual number should be unspecified, as a point of variation, and may be done dynamically.
* _Selection of different versions of elements that have the same interface but different behavioral or quality attribute characteristics_. Selection can occur at compile time, build time, or runtime. Selection mechanisms include static libraries, which contain external functions linked after compilation time; dynamic link libraries, which have the flexibility of static libraries but defer the decision until runtime based on context and execution conditions; and add-ons (e.g., plug-ins, extensions, and themes), which add or modify application functionality at runtime. By changing the libraries, we can change the implementation of functions whose names and signatures are known.

Some variation mechanisms can be introduced that change aspects of a particular software element. Modifying the source code each time the element is used in a new product—that is, clone-and-own—falls into this category, although it is undesirable. More sophisticated techniques include the following:

* _Extension points_. These are identified places in the architecture where additional behavior or functionality can be safely added.
* _Reflection_. This is the ability of a program to manipulate data on itself or its execution environment or state. Reflective programs can adjust their behavior based on their context.
* _Overloading_. This is a means of reusing a named functionality to operate on different types. Overloading promotes code reuse, but at the cost of understandability and code complexity.

   Other commonly used variation mechanisms include those in Table 25.2. 

   Choosing the right variation mechanism affects numerous costs:

* The skill set required to implement, or learn and use, the specific variation mechanism, such as server or framework programming
* The one-time costs of building or acquiring the tools (such as compilers or generators) required to create the variation mechanism
* The recurring cost and time to exercise the variation mechanism 
  
The choice of variation mechanism also affects downstream users and
developers:

* The targeted group of users that use the mechanism for product-specific adaptation, such as product developer, integrator, system administrator, and end user 

Finally, the choice of variation mechanism affects product quality:

* The impact of the variation mechanism on quality, such as possible performance penalties or memory consumption
* The impact on the mechanism’s maintainability

The architect should document the choice of variation mechanisms. In fact, the documentation of variation mechanisms is the primary way in which the documentation for a product line architecture differs from that of a conventional architecture. In the documentation template we presented in Chapter 18, the section

TABLE 25.2 Common Variation Mechanisms

Variation Mechanism | Properties Relevant to Building the Core Assets | Properties Relevant to Exercising the Variation Mechanism When Building Products
---|---|---
Inheritance; specializing or generalizing a particular class | **Cost**: Medium <br>**Skills**: Object-oriented languages | **Stakeholder**: Product developers <br>**Tools**: Compiler <br>**Cost**: Medium
Component substitution | **Cost**: Medium <br>**Skills**: Interface definitions | **Stakeholder**: Product developer, system administrator <br>**Tools**: Compiler <br>**Cost**: Low
Add-ons, plug-ins | **Cost**: High <br>**Skills**: Framework programming | **Stakeholder**: End user <br>**Tools**: None <br>**Cost**: Low
Templates | **Cost**: Medium <br>**Skills**: Abstractions | **Stakeholder**: Product developer, system administrator <br>**Tools**: None <br>**Cost**: Medium
Parameters (including text preprocessors) | **Cost**: Medium <br>**Skills**: No special skills required | **Stakeholder**: Product developer, system administrator, end user <br>**Tools**: None <br>**Cost**: Low
Generator | **Cost**: High <br>**Skills**: Generative programming | **Stakeholder**: System administrator, end user <br>**Tools**: Generator <br>**Cost**: Low
Aspects | **Cost**: Medium <br>**Skills**: Aspect-oriented programming | **Stakeholder**: Product developer <br>**Tools**: Aspect-oriented language compiler <br>**Cost**: Medium
Runtime conditionals | **Cost**: Medium <br>**Skills**: No special skills required | **Stakeholder**: None <br>**Tools**: None <br>**Cost**: No development cost; some performance cost
Configurator | **Cost**: Medium <br>**Skills**: No special skills required | **Stakeholder**: Product developer <br>**Tools**: Configurator <br>**Cost**: Low to medium

called the variability guide is reserved for exactly this purpose. The variability guide should describe each variation mechanism, how and when to exercise it, and what allowed variations it supports. The architecture documentation should also describe the architecture’s instantiation process—that is, how its variation points are exercised. Also, if certain combinations of variations are disallowed, then the documentation needs to explain valid and invalid variation choices.
