16.1 Gathering ASRs from Requirements Documents 从需求文档中收集ASR
===

An obvious location to look for candidate ASRs is in the requirements documents or in user stories. After all, we are looking for requirements, and requirements should be in requirements documents. Unfortunately, this is not usually the case, although as we will see, there is information in the requirements documents that can be of use.

**Don’t Get your Hopes up**

Many projects don’t create or maintain the kind of requirements document that professors in software engineering classes or authors of traditional software en-gineering books love to prescribe. Whether requirements are specified using the “MoSCoW” style (must, should, could, won’t), or as a collection of “user sto-ries,” neither of these is much help in nailing down quality attributes.

Furthermore, no architect just sits and waits until the requirements are “fin-ished” before starting work. The architect must begin while the requirements are still in flux. Consequently, the QA requirements are quite likely to be up in the air when the architect starts work. Even where they exist and are stable, require-ments documents often fail an architect in two ways.

First, most of what is in a requirements specification does not affect the architecture. As we’ve seen over and over, architectures are mostly driven or “shaped” by quality attribute requirements. These determine and constrain the most important architectural decisions. And yet the vast bulk of most require-ments specifications is focused on the required features and functionality of a system, which shape the architecture the least. The best software engineering practices do prescribe capturing quality attribute requirements. For example, the Software Engineering Body of Knowledge (SWEBOK) says that quality attribute requirements are like any other requirements. They must be captured if they are important, and they should be specified unambiguously and be testable.

In practice, though, we rarely see adequate capture of quality attribute re-quirements. How many times have you seen a requirement of the form “The system shall be modular” or “The system shall exhibit high usability” or “The system shall meet users’ performance expectations”? These are not requirements, but in the best case they are invitations for the architect to begin a conversation about what the requirements in these areas really are.

Second, much of what is useful to an architect is not in even the best re-quirements document. Many concerns that drive an architecture do not manifest themselves at all as observables in the system being specified, and so are not the subject of requirements specifications. ASRs often derive from business goals in the development organization itself; we’ll explore this in Section 16.3. De-velopmental qualities are also out of scope; you will rarely see a requirements document that describes teaming assumptions, for example. In an acquisition context, the requirements document represents the interests of the acquirer, not that of the developer. But as we saw in Chapter 3, stakeholders, the technical en-vironment, and the organization itself all play a role in influencing architectures.

**Sniffing Out ASRs from a Requirements Document**

Although requirements documents won’t tell an architect the whole story, they are an important source of ASRs. Of course, ASRs aren’t going to be conve-niently labeled as such; the architect is going to have to perform a bit of excava-tion and archaeology to ferret them out.

Chapter 4 categorizes the design decisions that architects have to make. Ta-ble 16.1 summarizes each category of architectural design decision, and it gives a list of requirements to look for that might affect that kind of decision. If a re-quirement affects the making of a critical architectural design decision, it is by definition an ASR.

TABLE 16.1 Early Design Decisions and Requirements That Can Affect Them

Design Decision Category | Look for Requirements Addressing . . .
---|---
Allocation of Responsibilities | Planned evolution of responsibilities, user roles, system modes, major processing steps, commercial packages
Coordination Model | Properties of the coordination (timeliness, currency, completeness, correctness, and consistency) <br>Names of external elements, protocols, sensors or actuators (devices), middleware, network configurations (including their security properties) <br> Evolution requirements on the list above
Data Model | Processing steps, information flows, major domain entities, access rights, persistence, evolution requirements
Management of Resources | Time, concurrency, memory footprint, scheduling, multiple users, multiple activities, devices, energy usage, soft resources (buffers, queues, etc.) <br>Scalability requirements on the list above
Mapping among Architectural Elements | Plans for teaming, processors, families of processors, evolution of processors, network configurations
Binding Time Decisions | Extension of or flexibility of functionality, regional distinctions, language distinctions, portability, calibrations, configurations
Choice of Technology | Named technologies, changes to technologies (planned and unplanned)
