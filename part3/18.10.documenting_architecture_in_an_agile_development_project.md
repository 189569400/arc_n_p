18.10 documenting architecture in an
agile development Project

“Agile” refers to an approach to software development that emphasizes rapid and
flexible development and de-emphasizes project and process infrastructure for their
own sake. In Chapter 15 we discuss the relationships between architecture and Ag-
ile. Here we focus just on how to document architecture in an Agile environment.

The Views and Beyond and Agile philosophies agree strongly on a central
point: If information isn’t needed, don’t document it. All documentation should
have an intended use and audience in mind, and be produced in a way that serves
both. One of the fundamental principles of technical documentation is “Write
for the reader.” That means understanding who will read the documentation and
how they will use it. If there is no audience, there is no need to produce the
documentation.
Architecture view selection is an example of applying this principle. The
Views and Beyond approach prescribes producing a view if and only if it ad-
dresses the concerns of an explicitly identified stakeholder community.
Another central idea to remember is that documentation is not a monolithic
activity that holds up all other progress until it is complete. The view selection
method given earlier prescribes producing the documentation in prioritized stages
to satisfy the needs of the stakeholders who need it now.
When producing Views and Beyond-based architecture documentation us-
ing Agile principles, keep the following in mind:
■
Adopt a template or standard organization to capture your design decisions.
■
Plan to document a view if (but only if) it has a strongly identified stake-
holder constituency.
■
Fill in the sections of the template for a view, and for information beyond
views, when (and in whatever order) the information becomes available.
But only do this if writing down this information will make it easier (or
cheaper or make success more likely) for someone downstream doing their
job.
■
Don’t worry about creating an architectural design document and then a
finer-grained design document. Produce just enough design information to
allow you to move on to code. Capture the design information in a format
that is simple to use and simple to change—a wiki, perhaps.
■
Don’t feel obliged to fill up all sections of the template, and certainly not
all at once. We still suggest you define and use rich templates because they
may be useful in some situations. But you can always write “N/A” for the
sections for which you don’t need to record the information (perhaps be-
cause you will convey it orally).
■
Agile teams sometimes make models in brief discussions by the white-
board. When documenting a view, the primary presentation may consist of
a digital picture of the whiteboard. Further information about the elements
(element catalog), rationale discussion (architecture background), variabil-
ity mechanisms being used (variability guide), and all else can be com-
municated verbally to the team—at least for now. Later on, if you find out
that it’s useful to record a piece of information about an element, a context
diagram, rationale for a certain design decision, or something else, the tem-
plate will have the right place ready to receive it.

The Software You’re Delivering Isn’t the Only Software That Matters
About ninety-nine percent of the treatment of architecture in this book (and
others) is concerned with the software elements that make up the opera-
tional system that is delivered to its customer. Component-and-connector
views show the units of runtime behavior of that system. Module views
show the units of implementation that have to be built in order to create
that system.
A colleague of mine is a project manager for a Fortune 500 software
company. On the day I wrote this sidebar, she found out that the develop-
ment platform her project relied on had been infected with a virulent new
virus, and the company’s IT department was removing it from service,
along with all the backup images, until the virus could be completely re-
moved. That was going to take about five days. After that, all of her project’s
software and tooling would have to be reinstalled and brought back up to
latest-version status. Her project was in user final acceptance test, racing
against a delivery deadline, and the IT department’s decision doomed
her project to join the countless others in our industry that are delivered
late. The snarling email she sent to the IT department for (a) allowing the
platform to become infected and (b) not providing a backup platform (real
or virtual) in a timely fashion would melt your screen.
The treatment of software architecture we describe in this book is
perfectly capable of representing and usefully incorporating software other
than the software that your customer is paying you to deliver. Allocation
views, recall, are about mapping that software to structures in the envi-
ronment. “Uses” views show which software elements rely on the correct
presence of other software in order to work. Context diagrams are all about
showing relations between your system and important elements of its envi-
ronment. It would be the easiest thing in the world to use these constructs
to represent support software including, in my friend’s case, the develop-
ment platform.
An avionics project I worked on years ago included in our decomposition
view a module called the System Generation Module. This consisted of all
of the software we needed to construct a loadable image of the product
we were building. Not a single byte of code from the System Generation
Module made it onto the aircraft, but it was as important as any other.
Even if you don’t build any of your support software but use off-the-shelf
development tools from your favorite vendor, someone in your organiza-
tion is responsible for the care and feeding of that software: its acquisition,
installation, configuration, and upgrade. That constitutes a nontrivial work
assignment, which suggests that support software also belongs in the work
assignment view (a kind of allocation view). And of course you always build
some of it yourself—test scripts, build scripts, and so forth—so it’s even
more deserving of a place in your architecture.

Promoting support and development software to first-class architec-
tural status makes us ask the right questions about it, especially the most
important one: What quality attributes do we require of it? Will it provide
us with the right security if (for example) we want to exclude our subcon-
tracting partners from access to some of our IP during development? Will it
have the availability to be up and running at 2 a.m. Sunday morning when
our project goes into its inevitable final delivery crunch? And if it crashes,
will the IT folks have someone standing by to bring it back up? Will it be
modifiable or configurable enough to support the way your project intends
to use it?
Think about what other software and environmental resources your proj-
ect depends on, and consider using the architectural tools, models, views,
and concepts at your disposal to help you do what architecture always
helps you do: Ask the right questions at the right time to expose risks and
begin to mitigate them. These concepts include quality attribute scenarios,
“uses” views, and deployment and work assignment views that include
support software.
—PCC

